/// Feed Provider - State management for social feed functionality
/// Handles feed posts, comments, likes, and following/followers operations

import 'package:flutter/material.dart';
import '../models/models.dart';
import '../data/data.dart';

class FeedProvider extends ChangeNotifier {
  final FeedRepository _repository = FeedRepository();

  // Feed state
  List<FeedWithUser> _recentFeeds = [];
  List<FeedWithUser> _forYouFeeds = [];
  Map<String, List<FeedComment>> _feedComments = {};
  Map<String, List<FeedLike>> _feedLikes = {};
  Map<String, bool> _likedPosts = {};

  // Loading states
  bool _isLoading = false;
  bool _isCommentsLoading = false;
  bool _isSending = false;

  // Error state
  String? _error;

  // Getters
  List<FeedWithUser> get recentFeeds => _recentFeeds;
  List<FeedWithUser> get forYouFeeds => _forYouFeeds;
  Map<String, List<FeedComment>> get feedComments => _feedComments;
  Map<String, List<FeedLike>> get feedLikes => _feedLikes;
  Map<String, bool> get likedPosts => _likedPosts;
  bool get isLoading => _isLoading;
  bool get isCommentsLoading => _isCommentsLoading;
  bool get isSending => _isSending;
  bool get hasError => _error != null;
  String? get error => _error;

  // =============================
  // FEED OPERATIONS
  // =============================

  /// Load recent feeds (following users + own posts)
  Future<void> loadRecentFeeds(String currentUserId) async {
    _setLoading(true);
    _clearError();

    try {
      print('FeedProvider: Loading recent feeds for user: $currentUserId');

      // Get feeds from following users + own posts
      final feeds = await _repository.getFollowingFeeds(
        currentUserId,
        limit: 20,
      );

      _recentFeeds = feeds;

      // Load likes and comments count for each feed
      await _loadFeedInteractions(feeds, currentUserId);

      print('FeedProvider: Loaded ${feeds.length} recent feeds');
      notifyListeners();
    } catch (e) {
      print('FeedProvider: Error loading recent feeds: $e');
      _setError('Failed to load recent feeds: $e');
    } finally {
      _setLoading(false);
    }
  }

  /// Load for you feeds (all public feeds)
  Future<void> loadForYouFeeds(String currentUserId) async {
    _setLoading(true);
    _clearError();

    try {
      print('FeedProvider: Loading for you feeds');

      // Get all public feeds (excluding own posts)
      final feeds = await _repository.getPublicFeeds(
        excludeUserId: currentUserId,
        limit: 20,
      );

      _forYouFeeds = feeds;

      // Load likes and comments count for each feed
      await _loadFeedInteractions(feeds, currentUserId);

      print('FeedProvider: Loaded ${feeds.length} for you feeds');
      notifyListeners();
    } catch (e) {
      print('FeedProvider: Error loading for you feeds: $e');
      _setError('Failed to load for you feeds: $e');
    } finally {
      _setLoading(false);
    }
  }

  /// Load feed interactions (likes, comments)
  Future<void> _loadFeedInteractions(
    List<FeedWithUser> feeds,
    String currentUserId,
  ) async {
    for (final feedWithUser in feeds) {
      final feedId = feedWithUser.feed.id;

      // Load comments for this feed
      final comments = await _repository.getFeedComments(feedId);
      _feedComments[feedId] = comments;

      // Load likes for this feed
      final likes = await _repository.getFeedLikes(feedId);
      _feedLikes[feedId] = likes;

      // Check if current user liked this post
      final isLiked = await _repository.isFeedLikedByUser(
        feedId,
        currentUserId,
      );
      _likedPosts[feedId] = isLiked;
    }
  }

  /// Create a new feed post
  Future<bool> createFeedPost({
    required String learnerId,
    required String contentText,
    List<String> imageUrls = const [],
  }) async {
    _setSending(true);
    _clearError();

    try {
      print('FeedProvider: Creating feed post');

      final feed = Feed(
        id: '', // Will be generated by database
        learnerId: learnerId,
        contentText: contentText,
        createdAt: DateTime.now(),
        imageUrls: imageUrls,
        likesCount: 0,
        commentsCount: 0,
        isLiked: false,
      );

      await _repository.createFeedPost(feed);

      // Add to recent feeds if it's from current user
      // You might want to refresh feeds instead
      await loadRecentFeeds(learnerId);

      print('FeedProvider: Feed post created successfully');
      return true;
    } catch (e) {
      print('FeedProvider: Error creating feed post: $e');
      _setError('Failed to create feed post: $e');
      return false;
    } finally {
      _setSending(false);
    }
  }

  /// Delete a feed post
  Future<bool> deleteFeedPost(String feedId, String currentUserId) async {
    _clearError();

    try {
      await _repository.deleteFeedPost(feedId);

      // Remove from local lists
      _recentFeeds.removeWhere((f) => f.feed.id == feedId);
      _forYouFeeds.removeWhere((f) => f.feed.id == feedId);
      _feedComments.remove(feedId);
      _feedLikes.remove(feedId);
      _likedPosts.remove(feedId);

      notifyListeners();
      return true;
    } catch (e) {
      _setError('Failed to delete feed post: $e');
      return false;
    }
  }

  // =============================
  // LIKE OPERATIONS
  // =============================

  /// Toggle like on a feed post
  Future<void> toggleFeedLike(String feedId, String userId) async {
    try {
      final isCurrentlyLiked = _likedPosts[feedId] ?? false;

      if (isCurrentlyLiked) {
        // Unlike the post
        await _repository.unlikeFeed(feedId, userId);
        _likedPosts[feedId] = false;

        // Remove from likes list
        _feedLikes[feedId]?.removeWhere((like) => like.learnerId == userId);

        // Update feed counts in both lists
        _updateFeedLikeCount(feedId, -1);
      } else {
        // Like the post
        await _repository.likeFeed(feedId, userId);
        _likedPosts[feedId] = true;

        // Add to likes list (you'd need to create a FeedLike object)
        _feedLikes[feedId] ??= [];
        // Note: You might want to create a proper FeedLike object here

        // Update feed counts in both lists
        _updateFeedLikeCount(feedId, 1);
      }

      notifyListeners();
    } catch (e) {
      print('FeedProvider: Error toggling like: $e');
      _setError('Failed to toggle like: $e');
    }
  }

  /// Update like count for a feed in local state
  void _updateFeedLikeCount(String feedId, int change) {
    // Update in recent feeds
    final recentIndex = _recentFeeds.indexWhere((f) => f.feed.id == feedId);
    if (recentIndex != -1) {
      final feedWithUser = _recentFeeds[recentIndex];
      final updatedFeed = feedWithUser.feed.copyWith(
        likesCount: feedWithUser.feed.likesCount + change,
        isLiked: _likedPosts[feedId] ?? false,
      );
      _recentFeeds[recentIndex] = FeedWithUser(
        feed: updatedFeed,
        userName: feedWithUser.userName,
        userAvatarUrl: feedWithUser.userAvatarUrl,
      );
    }

    // Update in for you feeds
    final forYouIndex = _forYouFeeds.indexWhere((f) => f.feed.id == feedId);
    if (forYouIndex != -1) {
      final feedWithUser = _forYouFeeds[forYouIndex];
      final updatedFeed = feedWithUser.feed.copyWith(
        likesCount: feedWithUser.feed.likesCount + change,
        isLiked: _likedPosts[feedId] ?? false,
      );
      _forYouFeeds[forYouIndex] = FeedWithUser(
        feed: updatedFeed,
        userName: feedWithUser.userName,
        userAvatarUrl: feedWithUser.userAvatarUrl,
      );
    }
  }

  // =============================
  // COMMENT OPERATIONS
  // =============================

  /// Add comment to feed post
  Future<bool> addFeedComment({
    required String feedId,
    required String learnerId,
    required String contentText,
    String? parentCommentId,
  }) async {
    _clearError();

    try {
      print('FeedProvider: Adding comment to feed: $feedId');

      final comment = FeedComment(
        id: '', // Will be generated by database
        feedId: feedId,
        learnerId: learnerId,
        contentText: contentText,
        parentCommentId: parentCommentId,
        createdAt: DateTime.now(),
        likesCount: 0,
        isLiked: false,
      );

      final createdComment = await _repository.addFeedComment(comment);

      // Add to local comments list
      _feedComments[feedId] ??= [];
      _feedComments[feedId]!.add(createdComment);

      // Update comment count in feeds
      _updateFeedCommentCount(feedId, 1);

      notifyListeners();
      return true;
    } catch (e) {
      print('FeedProvider: Error adding comment: $e');
      _setError('Failed to add comment: $e');
      return false;
    }
  }

  /// Load comments for a specific feed
  Future<void> loadFeedComments(String feedId) async {
    _isCommentsLoading = true;
    notifyListeners();

    try {
      final comments = await _repository.getFeedComments(feedId);
      _feedComments[feedId] = comments;
      notifyListeners();
    } catch (e) {
      _setError('Failed to load comments: $e');
    } finally {
      _isCommentsLoading = false;
      notifyListeners();
    }
  }

  /// Update comment count for a feed in local state
  void _updateFeedCommentCount(String feedId, int change) {
    // Update in recent feeds
    final recentIndex = _recentFeeds.indexWhere((f) => f.feed.id == feedId);
    if (recentIndex != -1) {
      final feedWithUser = _recentFeeds[recentIndex];
      final updatedFeed = feedWithUser.feed.copyWith(
        commentsCount: feedWithUser.feed.commentsCount + change,
      );
      _recentFeeds[recentIndex] = FeedWithUser(
        feed: updatedFeed,
        userName: feedWithUser.userName,
        userAvatarUrl: feedWithUser.userAvatarUrl,
      );
    }

    // Update in for you feeds
    final forYouIndex = _forYouFeeds.indexWhere((f) => f.feed.id == feedId);
    if (forYouIndex != -1) {
      final feedWithUser = _forYouFeeds[forYouIndex];
      final updatedFeed = feedWithUser.feed.copyWith(
        commentsCount: feedWithUser.feed.commentsCount + change,
      );
      _forYouFeeds[forYouIndex] = FeedWithUser(
        feed: updatedFeed,
        userName: feedWithUser.userName,
        userAvatarUrl: feedWithUser.userAvatarUrl,
      );
    }
  }

  // =============================
  // FOLLOW OPERATIONS
  // =============================

  /// Follow a user
  Future<bool> followUser(String followerId, String followedId) async {
    try {
      await _repository.followUser(followerId, followedId);
      // You might want to update the UI or reload feeds
      return true;
    } catch (e) {
      _setError('Failed to follow user: $e');
      return false;
    }
  }

  /// Unfollow a user
  Future<bool> unfollowUser(String followerId, String followedId) async {
    try {
      await _repository.unfollowUser(followerId, followedId);
      // You might want to update the UI or reload feeds
      return true;
    } catch (e) {
      _setError('Failed to unfollow user: $e');
      return false;
    }
  }

  // =============================
  // UTILITY METHODS
  // =============================

  void _setLoading(bool loading) {
    if (_isLoading != loading) {
      _isLoading = loading;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    }
  }

  void _setSending(bool sending) {
    if (_isSending != sending) {
      _isSending = sending;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    }
  }

  void _setError(String error) {
    if (_error != error) {
      _error = error;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    }
  }

  void _clearError() {
    if (_error != null) {
      _error = null;
      WidgetsBinding.instance.addPostFrameCallback((_) {
        notifyListeners();
      });
    }
  }

  /// Clear all data
  void clear() {
    _recentFeeds = [];
    _forYouFeeds = [];
    _feedComments = {};
    _feedLikes = {};
    _likedPosts = {};
    _isLoading = false;
    _isCommentsLoading = false;
    _isSending = false;
    _error = null;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      notifyListeners();
    });
  }

  @override
  void dispose() {
    clear();
    super.dispose();
  }
}
